<!DOCTYPE html>
<html>
<head>
    <title>Street View Panorama Ages</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        .legend {
            padding: 6px 8px;
            background: white;
            background: rgba(255,255,255,0.8);
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            border-radius: 5px;
        }

        .legend .year-item {
            line-height: 24px;
        }
        
        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }

        .legend i.inactive {
            opacity: 0.2;
        }

        .legend .active-item {
            font-weight: bold;
        }

        .legend h4 {
            margin: 0;
            line-height: 1.2; 
        }

        .legend .subtitle {
            color: #666;
            margin-top: 2px;
            margin-bottom: 8px;
            line-height: 1.2; 
        }

        .legend i.active {
            border: 1px solid black;
        }

        /* Back link styles */
        #back-link {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            background: white;
            background: rgba(255,255,255,0.8);
            border-radius: 4px;
            z-index: 1000;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            text-decoration: none;
            color: #333;
            font-family: sans-serif;
            font-size: 14px;
        }

        #back-link:hover {
            background: rgba(255,255,255,0.9);
            color: #000;
        }

        /* Progress bar styles */
        #progress-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 450px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
        }

        #progress-bar {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        #progress-fill {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s ease;
        }

        #progress-text {
            text-align: center;
            font-family: sans-serif;
            margin-top: 5px;
        }
    </style>
</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZSQGNSTEES"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZSQGNSTEES');
</script>
<body>
    <div id="map"></div>
    <a href="https://jonfroehlich.github.io/gsv-tracker/www/" id="back-link">← Back to Overview Map</a>
    <div id="progress-container">
        <div id="progress-bar">
            <div id="progress-fill"></div>
        </div>
        <div id="progress-text">Initializing download...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <script>
        function getColor(age) {
            const maxAge = 12;
            const ratio = Math.min(age / maxAge, 1);
            
            if (ratio < 0.5) {
                // Interpolate between yellow and orange
                const r = 255 - (ratio * 2 * (255 - 253));
                const g = 255 - (ratio * 2 * (255 - 141));
                const b = 178 - (ratio * 2 * (178 - 60));
                return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
            } else {
                // Interpolate between orange and red
                const adjustedRatio = (ratio - 0.5) * 2;
                const r = 253 - (adjustedRatio * (253 - 189));
                const g = 141 - (adjustedRatio * 141);
                const b = 60 - (adjustedRatio * (60 - 38));
                return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
            }
        }

        // Initialize the map with zoom control disabled, so we can
        // add it and set its position to the bottomleft
        const map = L.map('map', {
            zoomControl: false  // Disable default zoom control
        }).setView([0, 0], 13);

        // Add zoom control to bottom left
        L.control.zoom({
            position: 'bottomleft'
        }).addTo(map);

        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '© OpenStreetMap contributors © CARTO',
            maxZoom: 19
        }).addTo(map);

        // Add map click handler to reset selection
        map.on('click', function(e) {
            if (e.originalEvent.target === map._container) {
                activeYears.clear();
                Object.entries(markersByYear).forEach(([markerYear, markers]) => {
                    markers.forEach(marker => marker.addTo(map));
                });
                updateLegend(Object.keys(markersByYear).map(Number));
            }
        });

        // Store markers by year for filtering
        let markersByYear = {};
        let activeYears = new Set();

        // Create legend
        const legend = L.control({position: 'topright'});
        legend.onAdd = function (map) {
            const div = L.DomUtil.create('div', 'legend');
            return div;
        };
        legend.addTo(map);

        let cityNameGlobal = '';
        let stateNameGlobal = '';
        let totalPanosGlobal = 0;

        function updateLegend(years) {
            const div = document.querySelector('.legend');
            div.innerHTML = `
                <h4>${cityNameGlobal}, ${stateNameGlobal}</h4>
                <div class="subtitle">Total Panos: ${totalPanosGlobal.toLocaleString()}</div>
            `;
            
            const sortedYears = Array.from(years).sort((a, b) => b - a);
            sortedYears.forEach(year => {
                const currentYear = new Date().getFullYear();
                const age = currentYear - year;
                const color = getColor(age);
                const isActive = activeYears.has(year);
                const count = markersByYear[year].length;
                
                const itemClass = isActive ? 'active-item' : '';
                const iconClass = isActive ? 'active' : '';
                
                div.innerHTML += `
                    <div class="year-item ${itemClass}">
                        <i style="background:${color}" class="${iconClass}" onclick="toggleYear(${year})"></i>
                        ${year} (${count.toLocaleString()})
                    </div>`;
            });
        }

        function toggleYear(year) {
            const wasActive = activeYears.has(year);
            
            activeYears.clear();
            
            Object.entries(markersByYear).forEach(([markerYear, markers]) => {
                markers.forEach(marker => marker.addTo(map));
            });
            
            if (!wasActive) {
                activeYears.add(year);
                Object.entries(markersByYear).forEach(([markerYear, markers]) => {
                    if (parseInt(markerYear) !== year) {
                        markers.forEach(marker => marker.remove());
                    }
                });
            }
            
            updateLegend(Object.keys(markersByYear).map(Number));
        }

        // Get the CSV file from URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const csvFile = urlParams.get('file');
        const cityQuery = urlParams.get('city');

        // Remove any surrounding quotes and decode URL encoding
        const decodedCityQuery = cityQuery ? decodeURIComponent(cityQuery).replace(/^"(.*)"$/, '$1') : null;

        const citiesJsonFilename = 'cities.json.gz';
        const rawUrl = 'https://raw.githubusercontent.com/jonfroehlich/gsv-tracker/main/data/';

        // Levenshtein distance calculation for fuzzy matching
        function levenshteinDistance(a, b) {
            if (a.length === 0) return b.length;
            if (b.length === 0) return a.length;

            const matrix = [];

            // Initialize matrix
            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }

            // Fill in the rest of the matrix
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i-1) === a.charAt(j-1)) {
                        matrix[i][j] = matrix[i-1][j-1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i-1][j-1] + 1, // substitution
                            matrix[i][j-1] + 1,   // insertion
                            matrix[i-1][j] + 1    // deletion
                        );
                    }
                }
            }

            return matrix[b.length][a.length];
        }

        // Parse location query into components
        function parseLocationQuery(query, cities) {
            if (!query || typeof query !== 'string') {
                return null;
            }

            query = query.trim();
            const parts = query.split(',').map(part => part.trim());
            
            // Try to parse as "city, state, country"
            if (parts.length === 3) {
                return {
                    city: parts[0],
                    state: parts[1],
                    country: parts[2]
                };
            }
            // For "city, identifier" format, determine if second part is state or country
            else if (parts.length === 2) {
                const cityPart = parts[0];
                const identifierPart = parts[1].toLowerCase();
                
                // Get all unique state and country identifiers from the cities data
                const stateIdentifiers = new Set();  // Both codes and full names
                const countryIdentifiers = new Set(); // Both codes and full names
                cities.cities.forEach(cityData => {
                    if (cityData.city.state?.code) {
                        stateIdentifiers.add(cityData.city.state.code.toLowerCase());
                    }
                    if (cityData.city.state?.name) {
                        stateIdentifiers.add(cityData.city.state.name.toLowerCase());
                    }
                    if (cityData.city.country?.code) {
                        countryIdentifiers.add(cityData.city.country.code.toLowerCase());
                    }
                    if (cityData.city.country?.name) {
                        countryIdentifiers.add(cityData.city.country.name.toLowerCase());
                    }
                });

                // Check if identifier matches exactly with any state or country identifier
                const isExactStateMatch = stateIdentifiers.has(identifierPart);
                const isExactCountryMatch = countryIdentifiers.has(identifierPart);

                // If it's an exact match to a country (code or name) but not a state,
                // treat it as a country
                if (isExactCountryMatch && !isExactStateMatch) {
                    return {
                        city: cityPart,
                        state: null,
                        country: identifierPart
                    };
                }
                // If it's an exact match to a state (code or name) but not a country,
                // treat it as a state
                else if (isExactStateMatch && !isExactCountryMatch) {
                    return {
                        city: cityPart,
                        state: identifierPart,
                        country: null
                    };
                }
                // If it matches both or neither, prefer state interpretation
                // (this can be adjusted based on your preferred default)
                else {
                    return {
                        city: cityPart,
                        state: identifierPart,
                        country: null
                    };
                }
            }
            // Just city
            else if (parts.length === 1) {
                return {
                    city: parts[0],
                    state: null,
                    country: null
                };
            }

            return null;
        }

        // Find best matching city with fuzzy matching
        function findBestMatchingCity(parsedQuery, citiesData, maxDistance = 3) {
            console.log('Finding best matching city for parsed query:', parsedQuery);
            console.log('Using distance threshold:', maxDistance);
            
            // Debug log to see the structure
            console.log('First city in data:', JSON.stringify(citiesData.cities[0], null, 2));
            console.log('Cities data type:', typeof citiesData);
            console.log('Cities array type:', Array.isArray(citiesData.cities));
            console.log('Total cities:', citiesData.cities.length);

            if (!parsedQuery || !parsedQuery.city) {
                console.log('Invalid parsed query - missing required city');
                return {
                    match: null,
                    error: "Invalid query format. Please use 'City, State', 'City, Country', or 'City, State, Country' format."
                };
            }

            let bestMatch = null;
            let bestDistance = Infinity;
            let matchedCities = [];

            citiesData.cities.forEach(cityData => {
                // Debug log for each city being processed
                console.log('Processing city:', cityData);

                const cityNameLower = cityData.city.toLowerCase();
                const queryNameLower = parsedQuery.city.toLowerCase();
                const cityDistance = levenshteinDistance(queryNameLower, cityNameLower);
                
                console.log(`\nComparing city: "${cityData.city}"`);
                console.log(`City distance (${queryNameLower} vs ${cityNameLower}):`, cityDistance);
                
                let cityMatch = {
                    cityDistance: cityDistance
                };

                // If state is provided, calculate state match
                if (parsedQuery.state) {
                    const stateCode = cityData.city.state.code;
                    const stateName = cityData.city.state.name;
                    const queryState = parsedQuery.state.toLowerCase();
                    
                    const stateCodeDistance = levenshteinDistance(queryState, stateCode.toLowerCase());
                    const stateNameDistance = levenshteinDistance(queryState, stateName.toLowerCase());
                    cityMatch.stateDistance = Math.min(stateCodeDistance, stateNameDistance);
                    
                    console.log('State matching:');
                    console.log(` - Code distance (${queryState} vs ${stateCode.toLowerCase()}):`, stateCodeDistance);
                    console.log(` - Name distance (${queryState} vs ${stateName.toLowerCase()}):`, stateNameDistance);
                    console.log(` - Final state distance:`, cityMatch.stateDistance);
                }

                // If country is provided, calculate country match
                if (parsedQuery.country) {
                    const countryCode = cityData.city.country.code;
                    const countryName = cityData.city.country.name;
                    const queryCountry = parsedQuery.country.toLowerCase();
                    
                    const countryCodeDistance = levenshteinDistance(queryCountry, countryCode.toLowerCase());
                    const countryNameDistance = levenshteinDistance(queryCountry, countryName.toLowerCase());
                    cityMatch.countryDistance = Math.min(countryCodeDistance, countryNameDistance);
                    
                    console.log('Country matching:');
                    console.log(` - Code distance (${queryCountry} vs ${countryCode.toLowerCase()}):`, countryCodeDistance);
                    console.log(` - Name distance (${queryCountry} vs ${countryName.toLowerCase()}):`, countryNameDistance);
                    console.log(` - Final country distance:`, cityMatch.countryDistance);
                }

                // Calculate total distance with weights
                cityMatch.totalDistance = cityMatch.cityDistance * 2; // Weight city matches more heavily
                if (cityMatch.stateDistance !== undefined) {
                    cityMatch.totalDistance += cityMatch.stateDistance;
                }
                if (cityMatch.countryDistance !== undefined) {
                    cityMatch.totalDistance += cityMatch.countryDistance;
                }
                
                console.log('Total weighted distance:', cityMatch.totalDistance);

                matchedCities.push({
                    city: cityData,
                    match: cityMatch
                });

                if (cityMatch.totalDistance < bestDistance) {
                    bestDistance = cityMatch.totalDistance;
                    bestMatch = cityData;
                }
            });

            // Sort matched cities by distance for suggestions
            matchedCities.sort((a, b) => a.match.totalDistance - b.match.totalDistance);

            // If best match exceeds threshold, return helpful error with suggestions
            if (bestDistance > maxDistance) {
                console.log('Best match distance', bestDistance, 'exceeds threshold', maxDistance);
                console.log('Getting top 3 suggestions for user...');
                
                const suggestions = matchedCities.slice(0, 3).map(match => {
                    const suggestion = {
                        city: match.city.city.name,
                        state: match.city.city.state.code,
                        country: match.city.city.country.code,
                        distance: match.match.totalDistance
                    };
                    console.log('Suggestion:', suggestion);
                    return suggestion;
                });

                let errorMessage = "No close matches found. ";
                if (suggestions.length > 0) {
                    errorMessage += "Did you mean:\n" + suggestions.map(s => 
                        `${s.city}, ${s.state}, ${s.country}`
                    ).join('\n');
                }

                return {
                    match: null,
                    error: errorMessage,
                    suggestions
                };
            }

            return {
                match: bestMatch,
                distance: bestDistance
            };
        }
        
        async function loadData() {
            
            if (!csvFile && !decodedCityQuery) {
                alert('Please provide either a file parameter or city parameter');
                return;
            }

            try {
                // Show progress container
                const progressContainer = document.getElementById('progress-container');
                const progressFill = document.getElementById('progress-fill');
                const progressText = document.getElementById('progress-text');
                progressContainer.style.display = 'block';

                let targetFile = csvFile;

                // If we have a city query, find the matching city from cities.json.gz
                if (!csvFile && decodedCityQuery) {
                    progressText.textContent = `Finding city data for: ${decodedCityQuery}`;
                    
                    // Load and parse cities.json.gz
                    const citiesResponse = await fetch(rawUrl + citiesJsonFilename);
                    const citiesBuffer = await citiesResponse.arrayBuffer();
                    const citiesText = pako.inflate(new Uint8Array(citiesBuffer), { to: 'string' });
                    const citiesData = JSON.parse(citiesText);

                    console.log(`Loaded ${citiesData.cities.length} cities from ${citiesJsonFilename}`);
                    console.log(`Attempting to find city for query: ${decodedCityQuery}`);

                    // Find best matching city
                    // Parse query first to determine if two-part format is state or country
                    const parsedQuery = parseLocationQuery(decodedCityQuery, citiesData);
                    if (!parsedQuery) {
                        progressContainer.style.display = 'none';
                        alert('Invalid query format. Please use "City, State", "City, Country", or "City, State, Country" format.');
                        return;
                    }

                    const result = findBestMatchingCity(parsedQuery, citiesData);

                    if (!result.match) {
                        progressContainer.style.display = 'none';
                        alert(result.error);
                        return;
                    }

                    targetFile = result.match.data_file.filename;

                    // Update URL without reloading page
                    const newUrl = new URL(window.location);
                    newUrl.searchParams.set('file', targetFile);
                    window.history.pushState({}, '', newUrl);
                }


                // Now load the city-specific JSON metadata file
                progressText.textContent = 'Loading city metadata...';
                const jsonResponse = await fetch(rawUrl + targetFile.replace('.csv.gz', '.json.gz'));
                const jsonBuffer = await jsonResponse.arrayBuffer();
                const jsonText = pako.inflate(new Uint8Array(jsonBuffer), { to: 'string' });
                const stats = JSON.parse(jsonText);

                const totalBytes = stats.data_file.size_bytes;
                const fileSizeMB = (totalBytes / (1024 * 1024)).toFixed(1);

                // Get city and state from JSON metadata
                const cityName = stats.city.name;
                const stateName = stats.city.state;

                // Update progress text for main CSV download
                progressText.textContent = `Downloading ${fileSizeMB} MB for ${cityName}, ${stateName}...`;

                // Update document title
                document.title = `Street View Data: ${cityName}, ${stateName}`;
                
                // Store globally for legend
                cityNameGlobal = cityName;
                stateNameGlobal = stateName;

                // Add region outline
                const bounds = stats.city.bounds;
                const regionCoords = [
                    [bounds.min_lat, bounds.min_lon],
                    [bounds.min_lat, bounds.max_lon],
                    [bounds.max_lat, bounds.max_lon],
                    [bounds.max_lat, bounds.min_lon]
                ];

                // Format dates
                const oldestDate = new Date(stats.google_panos.age_stats.oldest_pano_date);
                const newestDate = new Date(stats.google_panos.age_stats.newest_pano_date);

                // Create hover text
                const hoverInfo = `
                    <div style="font-family: sans-serif;">
                        <strong>${cityName}, ${stateName}</strong><br>
                        <br>
                        Total panoramas: ${stats.all_panos.duplicate_stats.total_unique_panos.toLocaleString()}<br>
                        Google panoramas: ${stats.google_panos.duplicate_stats.total_unique_panos.toLocaleString()}<br>
                        <br>
                        Search grid area: ${stats.search_grid.area_km2.toFixed(1)} km²<br>
                        Total search points: ${stats.search_grid.total_search_points.toLocaleString()}<br>
                        Grid step size: ${stats.search_grid.step_length_meters} meters<br>
                        <br>
                        Oldest pano: ${oldestDate.toLocaleDateString()}<br>
                        Newest pano: ${newestDate.toLocaleDateString()}<br>
                        Median age: ${stats.google_panos.age_stats.median_pano_age_years.toFixed(1)} years<br>
                        Average age: ${stats.google_panos.age_stats.avg_pano_age_years.toFixed(1)} years 
                        (SD=${stats.google_panos.age_stats.stdev_pano_age_years.toFixed(1)} years)
                    </div>
                `;

                // Add the polygon to the map
                const regionPolygon = L.polygon(regionCoords, {
                    color: 'cyan',
                    weight: 2,
                    opacity: 0.8,
                    fillColor: 'cyan',
                    fill: false,
                    fillOpacity: 0.1
                }).addTo(map);

                // Add hover popup
                regionPolygon.bindTooltip(hoverInfo, {
                    sticky: true, // Tooltip follows mouse
                    opacity: 0.9,
                    direction: 'auto'
                });
                
                
                // Fetch the CSV file with progress tracking
                const response = await fetch(rawUrl + targetFile);
                const reader = response.body.getReader();
                const chunks = [];
                let receivedBytes = 0;

                while(true) {
                    const {done, value} = await reader.read();
                    
                    if (done) break;
                    
                    chunks.push(value);
                    receivedBytes += value.length;
                    
                    // Update progress
                    const progress = (receivedBytes / totalBytes) * 100;
                    progressFill.style.width = progress + '%';
                    progressText.textContent = `Downloading ${fileSizeMB} MB for ${cityName}, ${stateName}... ${Math.round(progress)}%`;
                }

                // Concatenate chunks
                const allChunks = new Uint8Array(receivedBytes);
                let position = 0;
                for(const chunk of chunks) {
                    allChunks.set(chunk, position);
                    position += chunk.length;
                }

                // Hide progress container
                progressContainer.style.display = 'none';

                // Decompress and parse
                const decompressed = pako.inflate(allChunks, { to: 'string' });
                Papa.parse(decompressed, {
                    header: true,
                    dynamicTyping: true,
                    complete: function(results) {
                        let validPoints = [];
                        const years = new Set();
                        const processedPanos = new Set();
                        
                        results.data.forEach(row => {
                            if (row.status === 'OK' && 
                                row.copyright_info === '© Google' && 
                                row.capture_date &&
                                row.pano_lat != null &&
                                row.pano_lon != null &&
                                row.pano_id &&
                                !processedPanos.has(row.pano_id)) {  // Only process if we haven't seen this pano_id
                                
                                processedPanos.add(row.pano_id);  // Mark this pano_id as processed
                                
                                const captureDate = new Date(row.capture_date);
                                const year = captureDate.getFullYear();
                                const currentYear = new Date().getFullYear();
                                const age = currentYear - year;
                                
                                // Calculate age with precision
                                const ageInYears = (new Date() - captureDate) / (1000 * 60 * 60 * 24 * 365.25);
                                const ageFormatted = ageInYears < 1 ? 
                                    `${Math.round(ageInYears * 12)} months` : 
                                    `${ageInYears.toFixed(1)} years`;

                                const marker = L.circleMarker([row.pano_lat, row.pano_lon], {
                                    radius: 3,
                                    fillColor: getColor(age),
                                    color: '#000',
                                    weight: 0,
                                    opacity: 1,
                                    fillOpacity: 0.8
                                });
                                
                                const popupContent = `
                                    <div style="font-family: sans-serif;">
                                        <strong>Capture Date:</strong> ${captureDate.toLocaleDateString()}<br>
                                        <strong>Age:</strong> ${ageFormatted}<br>
                                        <strong>Photographer:</strong> Google<br>
                                        <strong>Pano ID:</strong> ${row.pano_id}<br>
                                        <br>
                                        <a href="https://www.google.com/maps/@?api=1&map_action=pano&pano=${row.pano_id}" 
                                           target="_blank" 
                                           style="color: #2196F3; text-decoration: none;">
                                           View in Google Street View
                                        </a>
                                    </div>
                                `;
                                
                                marker.bindPopup(popupContent);
                                marker.addTo(map);
                                
                                if (!markersByYear[year]) {
                                    markersByYear[year] = [];
                                }
                                markersByYear[year].push(marker);
                                years.add(year);
                                
                                validPoints.push([row.pano_lat, row.pano_lon]);
                            }
                        });
                        
                        // Update total pano count
                        totalPanosGlobal = processedPanos.size;
                        
                        updateLegend(years);
                        
                        if (validPoints.length > 0) {
                            const bounds = L.latLngBounds(validPoints);
                            map.fitBounds(bounds);
                        }
                    }
                });

            } catch (error) {
                console.error('Error loading or parsing file:', error);
                alert('Error loading or parsing the file. Please check the console for details.');
                document.getElementById('progress-container').style.display = 'none';
            }
        }

        loadData();
    </script>
</body>
</html>